const { Client, GatewayIntentBits, EmbedBuilder, SlashCommandBuilder, REST, Routes, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

const client = new Client({
    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent]
});

const prefix = '.';
const DEV_LOG_CHANNEL_ID = '1414044553312468992';
const OWNER_ID = '1017206528928923648';
const ANNOUNCEMENT_CHANNEL_ID = '1414421793393082461';

const pendingAnnouncements = new Map();

const commands = [
    new SlashCommandBuilder()
        .setName('allcmds')
        .setDescription('Display all available bot commands (Staff Quick Reference)'),
    
    new SlashCommandBuilder()
        .setName('announcement')
        .setDescription('Create a custom announcement with translations (Owner Only)')
        .addStringOption(option =>
            option.setName('title_en')
                .setDescription('Announcement title in English')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('description_en')
                .setDescription('Announcement description in English')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('title_de')
                .setDescription('Announcement title in German')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('description_de')
                .setDescription('Announcement description in German')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('title_fr')
                .setDescription('Announcement title in French')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('description_fr')
                .setDescription('Announcement description in French')
                .setRequired(true))
];

const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);

async function registerCommands() {
    await rest.put(Routes.applicationCommands(process.env.CLIENT_ID), { body: commands });
    console.log('Commands registered successfully.');
}

registerCommands().catch(console.error);

client.once('ready', () => {
    console.log(`Bot is ready! Logged in as ${client.user.tag}`);
    client.user.setPresence({
        activities: [{ name: 'Doing things others cant.', type: 4 }],
        status: 'online'
    });
});

function createTranslationButtons() {
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('translate_en')
                .setLabel('English')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üá∫üá∏'),
            new ButtonBuilder()
                .setCustomId('translate_de')
                .setLabel('Deutsch')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üá©üá™'),
            new ButtonBuilder()
                .setCustomId('translate_fr')
                .setLabel('Fran√ßais')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üá´üá∑')
        );
}

function createConfirmationButtons(announcementId) {
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId(`confirm_${announcementId}`)
                .setLabel('Confirm & Send with @everyone')
                .setStyle(ButtonStyle.Success)
                .setEmoji('‚úÖ'),
            new ButtonBuilder()
                .setCustomId(`cancel_${announcementId}`)
                .setLabel('Cancel')
                .setStyle(ButtonStyle.Danger)
                .setEmoji('‚ùå')
        );
}

// Announcement embed creator
function createAnnouncementEmbed(data, language = 'en') {
    const embed = new EmbedBuilder().setColor('#FFFFFF').setTimestamp();
    
    if (language === 'en') {
        embed.setTitle(data.title_en).setDescription(data.description_en);
    } else if (language === 'de') {
        embed.setTitle(data.title_de).setDescription(data.description_de);
    } else if (language === 'fr') {
        embed.setTitle(data.title_fr).setDescription(data.description_fr);
    }
    
    return embed;
}

// Support ticket embed
function createSupportTicketEmbed(language = 'en') {
    const embed = new EmbedBuilder().setColor('#FFFFFF').setTimestamp();
    
    if (language === 'en') {
        embed.setTitle('üìã Support Ticket Requirements')
            .setDescription('In order to assist you efficiently, please ensure you provide the following when opening a ticket:')
            .addFields(
                { name: 'üìπ Required Information', value: '‚Ä¢ A clear, high-quality video demonstrating the issue\n‚Ä¢ A screenshot of the error message(s)\n‚Ä¢ The name of the product you are using\n‚Ä¢ The version of Windows you are running\n‚Ä¢ A screenshot of each tab within your Windows Security settings' },
                { name: 'üîß Diagnostic Tool', value: 'Run the following diagnostic setup file and provide a screenshot when prompted:\n[TX Support Tool](https://cdn.discordapp.com/attachments/1413199327249170472/1418206411178901558/TX_Support_Tool.exe)' },
                { name: '‚ö†Ô∏è Important Notes', value: '‚Ä¢ Failure to follow these steps may result in delays or prevent us from providing effective support\n‚Ä¢ Please ensure all requested information is submitted promptly\n‚Ä¢ Once everything is submitted, kindly wait for an administrator to respond\n‚Ä¢ Inactivity within the ticket may result in it being automatically closed' }
            )
            .setFooter({ text: 'Support Team ‚Ä¢ Please follow all requirements' });
    } else if (language === 'de') {
        embed.setTitle('üìã Support-Ticket Anforderungen')
            .setDescription('Um Ihnen effizient zu helfen, stellen Sie bitte beim √ñffnen eines Tickets die folgenden Informationen bereit:')
            .addFields(
                { name: 'üìπ Erforderliche Informationen', value: '‚Ä¢ Ein klares, hochwertiges Video, das das Problem demonstriert\n‚Ä¢ Ein Screenshot der Fehlermeldung(en)\n‚Ä¢ Der Name des Produkts, das Sie verwenden\n‚Ä¢ Die Version von Windows, die Sie verwenden\n‚Ä¢ Ein Screenshot jedes Tabs in Ihren Windows-Sicherheitseinstellungen' },
                { name: 'üîß Diagnose-Tool', value: 'F√ºhren Sie die folgende Diagnose-Datei aus und stellen Sie einen Screenshot bereit:\n[TX Support Tool](https://cdn.discordapp.com/attachments/1413199327249170472/1418206411178901558/TX_Support_Tool.exe)' },
                { name: '‚ö†Ô∏è Wichtige Hinweise', value: '‚Ä¢ Das Nichtbefolgen dieser Schritte kann zu Verz√∂gerungen f√ºhren oder uns daran hindern, effektiven Support zu bieten\n‚Ä¢ Bitte stellen Sie sicher, dass alle angeforderten Informationen umgehend √ºbermittelt werden\n‚Ä¢ Warten Sie nach der √úbermittlung geduldig auf die Antwort eines Administrators\n‚Ä¢ Inaktivit√§t im Ticket kann zur automatischen Schlie√üung f√ºhren' }
            )
            .setFooter({ text: 'Support Team ‚Ä¢ Bitte befolgen Sie alle Anforderungen' });
    } else if (language === 'fr') {
        embed.setTitle('üìã Exigences du Ticket de Support')
            .setDescription('Afin de vous aider efficacement, veuillez vous assurer de fournir les √©l√©ments suivants lors de l\'ouverture d\'un ticket:')
            .addFields(
                { name: 'üìπ Informations Requises', value: '‚Ä¢ Une vid√©o claire et de haute qualit√© d√©montrant le probl√®me\n‚Ä¢ Une capture d\'√©cran du/des message(s) d\'erreur\n‚Ä¢ Le nom du produit que vous utilisez\n‚Ä¢ La version de Windows que vous utilisez\n‚Ä¢ Une capture d\'√©cran de chaque onglet dans vos param√®tres de s√©curit√© Windows' },
                { name: 'üîß Outil de Diagnostic', value: 'Ex√©cutez le fichier de configuration de diagnostic suivant et fournissez une capture d\'√©cran:\n[TX Support Tool](https://cdn.discordapp.com/attachments/1413199327249170472/1418206411178901558/TX_Support_Tool.exe)' },
                { name: '‚ö†Ô∏è Notes Importantes', value: '‚Ä¢ Ne pas suivre ces √©tapes peut entra√Æner des retards ou nous emp√™cher de fournir un support efficace\n‚Ä¢ Veuillez vous assurer que toutes les informations demand√©es sont soumises rapidement\n‚Ä¢ Une fois tout soumis, veuillez attendre patiemment qu\'un administrateur r√©ponde\n‚Ä¢ L\'inactivit√© dans le ticket peut entra√Æner sa fermeture automatique' }
            )
            .setFooter({ text: '√âquipe de Support ‚Ä¢ Veuillez suivre toutes les exigences' });
    }
    return embed;
}

// Get embed for any command type
function getCommandEmbed(commandType, language) {
    switch(commandType) {
        case 'supportticket':
            return createSupportTicketEmbed(language);
        case 'hwidreset':
            const hwidEmbed = new EmbedBuilder().setColor('#FFFFFF').setTimestamp();
            if (language === 'en') {
                hwidEmbed.setTitle('üîÑ HWID Reset Requirements')
                    .setDescription('To assist you with your HWID reset request, please provide the following information:')
                    .addFields(
                        { name: 'üìÑ Required Documents', value: '‚Ä¢ A clear and detailed image of your invoice ID\n‚Ä¢ A screenshot or photo of your payment confirmation\n‚Ä¢ The email associated with your key\n‚Ä¢ The reason you are requesting a reset' },
                        { name: '‚è≥ Processing Time', value: 'Once all required information has been submitted, kindly allow some time for our team to review and respond accordingly.' }
                    )
                    .setFooter({ text: 'HWID Reset Team ‚Ä¢ All information is required' });
            }
            return hwidEmbed;
        // Add other command types as needed
        default:
            return new EmbedBuilder().setColor('#FFFFFF').setTitle('Command').setDescription('Command embed');
    }
}

async function logCommand(user, commandName) {
    const devChannel = client.channels.cache.get(DEV_LOG_CHANNEL_ID);
    if (devChannel) {
        const logEmbed = new EmbedBuilder()
            .setColor('#4ECDC4')
            .setTitle('üìä Command Used')
            .addFields(
                { name: 'üë§ User', value: user.username, inline: true },
                { name: '‚ö° Command', value: `.${commandName}`, inline: true }
            )
            .setTimestamp();
        
        devChannel.send({ embeds: [logEmbed] }).catch(() => {});
    }
}

client.on('interactionCreate', async (interaction) => {
    if (interaction.isChatInputCommand()) {
        if (interaction.commandName === 'allcmds') {
            const embed = new EmbedBuilder()
                .setColor('#FFFFFF')
                .setTitle('ü§ñ All Bot Commands')
                .setDescription('Complete command list with DM translations.')
                .addFields(
                    { name: 'üìã Support Commands', value: '`.supportticket` - Support requirements\n`.hwidreset` - HWID reset requirements\n`.hwidresetdone` - HWID reset completion\n`.ticketdone` - Ticket closure' },
                    { name: 'üîß Help Commands', value: '`.status` - Product status\n`.unlockerhelp` - Unlocker guide\n`.setupguide` - Setup documentation\n`.refundprocess` - Refund policy' },
                    { name: '‚ö° Management Commands', value: '`.escalated` - Escalation notice\n`.pleasewait` - Please wait message\n`.allcmds` - Command list' },
                    { name: 'üëë Owner Commands', value: '`/announcement` - Create custom announcements (Owner Only)' }
                )
                .setTimestamp();
            await interaction.reply({ embeds: [embed], ephemeral: true }).catch(() => {});
        }

        if (interaction.commandName === 'announcement') {
            if (interaction.user.id !== OWNER_ID) {
                await interaction.reply({ content: 'You do not have permission to use this command.', ephemeral: true }).catch(() => {});
                return;
            }

            const announcementData = {
                title_en: interaction.options.getString('title_en'),
                description_en: interaction.options.getString('description_en'),
                title_de: interaction.options.getString('title_de'),
                description_de: interaction.options.getString('description_de'),
                title_fr: interaction.options.getString('title_fr'),
                description_fr: interaction.options.getString('description_fr')
            };

            const announcementId = Date.now().toString();
            pendingAnnouncements.set(announcementId, announcementData);

            const previewEmbed = createAnnouncementEmbed(announcementData, 'en');
            const translationButtons = createTranslationButtons();
            const confirmButtons = createConfirmationButtons(announcementId);

            await interaction.reply({
                content: 'üìã **Announcement Preview** (No ping yet)',
                embeds: [previewEmbed],
                components: [translationButtons, confirmButtons]
            }).catch(() => {});
        }
    }

    if (interaction.isButton()) {
        // Handle translation buttons - DM the user
        if (interaction.customId.startsWith('translate_')) {
            const language = interaction.customId.split('_')[1];
            
            // Send ephemeral confirmation
            await interaction.reply({ 
                content: 'Check your DMs for the translation!', 
                ephemeral: true 
            }).catch(() => {});

            // Determine what to translate and send DM
            let embedToSend;
            
            // Check if it's an announcement
            if (interaction.message.content && interaction.message.content.includes('Announcement Preview')) {
                // Find announcement data
                for (const [id, data] of pendingAnnouncements.entries()) {
                    embedToSend = createAnnouncementEmbed(data, language);
                    break;
                }
            } else {
                // It's a regular command - determine which one based on title
                const originalTitle = interaction.message.embeds[0].title;
                if (originalTitle.includes('Support Ticket') || originalTitle.includes('Support-Ticket') || originalTitle.includes('Ticket de Support')) {
                    embedToSend = createSupportTicketEmbed(language);
                } else {
                    // Default fallback
                    embedToSend = new EmbedBuilder()
                        .setColor('#FFFFFF')
                        .setTitle('Translation')
                        .setDescription('Translation content')
                        .setTimestamp();
                }
            }

            // Send DM to user
            if (embedToSend) {
                try {
                    await interaction.user.send({ embeds: [embedToSend] });
                } catch (error) {
                    console.log('Could not send DM to user');
                }
            }
        }

        // Handle confirmation buttons
        if (interaction.customId.startsWith('confirm_')) {
            if (interaction.user.id !== OWNER_ID) {
                await interaction.reply({ content: 'Only the owner can confirm announcements.', ephemeral: true }).catch(() => {});
                return;
            }

            const announcementId = interaction.customId.split('_')[1];
            const announcementData = pendingAnnouncements.get(announcementId);
            
            if (announcementData) {
                const announcementChannel = client.channels.cache.get(ANNOUNCEMENT_CHANNEL_ID);
                if (announcementChannel) {
                    const finalEmbed = createAnnouncementEmbed(announcementData, 'en');
                    const translationButtons = createTranslationButtons();
                    
                    await announcementChannel.send({
                        content: '@everyone',
                        embeds: [finalEmbed],
                        components: [translationButtons]
                    }).catch(() => {});
                    
                    await interaction.update({
                        content: '‚úÖ **Announcement sent successfully!**',
                        embeds: [],
                        components: []
                    }).catch(() => {});
                    
                    pendingAnnouncements.delete(announcementId);
                }
            }
        }

        if (interaction.customId.startsWith('cancel_')) {
            if (interaction.user.id !== OWNER_ID) {
                await interaction.reply({ content: 'Only the owner can cancel announcements.', ephemeral: true }).catch(() => {});
                return;
            }

            const announcementId = interaction.customId.split('_')[1];
            pendingAnnouncements.delete(announcementId);
            
            await interaction.update({
                content: '‚ùå **Announcement cancelled.**',
                embeds: [],
                components: []
            }).catch(() => {});
        }
    }
});

client.on('messageCreate', async (message) => {
    if (!message.content.startsWith(prefix) || message.author.bot) return;

    const command = message.content.slice(prefix.length).trim().toLowerCase();

    if (command === 'supportticket') {
        const embed = createSupportTicketEmbed('en');
        const buttons = createTranslationButtons();
        
        await message.delete().catch(() => {});
        await message.channel.send({ embeds: [embed], components: [buttons] }).catch(() => {});
        logCommand(message.author, 'supportticket');
    }

    if (command === 'allcmds') {
        const embed = new EmbedBuilder()
            .setColor('#FFFFFF')
            .setTitle('ü§ñ All Bot Commands')
            .addFields(
                { name: 'üìã Support Commands', value: '`.supportticket` - Support requirements' },
                { name: 'üìù Staff Tools', value: '`.allcmds` - This list\n`/allcmds` - Private staff guide' }
            )
            .setTimestamp();
        
        await message.delete().catch(() => {});
        await message.channel.send({ embeds: [embed] }).catch(() => {});
        logCommand(message.author, 'allcmds');
    }
});

client.login(process.env.DISCORD_TOKEN);
